// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

import 'package:flutter_surrealdb/utils.dart';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `parse_resource`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`

String greet({required String name}) =>
    RustLib.instance.api.crateApiSimpleGreet(name: name);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SurrealProxy>>
abstract class SurrealProxy implements RustOpaqueInterface {
  Future<void> authenticate({required String token});

  Future<dynamic> create({required String res});

  Future<void> delete({required String resource});

  Future<void> export_({required String path});

  Future<void> import_({required String path});

  Future<dynamic> insert({required String res, required dynamic data});

  Future<void> invalidate();

  static Future<SurrealProxy> newMem() =>
      RustLib.instance.api.crateApiSimpleSurrealProxyNewMem();

  static Future<SurrealProxy> newRocksdb({required String path}) =>
      RustLib.instance.api.crateApiSimpleSurrealProxyNewRocksdb(path: path);

  Future<List<dynamic>> query(
      {required String query, required Map<String, dynamic> vars});

  Future<dynamic> run({required String function, required dynamic args});

  Future<dynamic> select({required String resource});

  Future<void> set_({required String key, required dynamic value});

  Future<String> signin(
      {required String namespace,
      required String database,
      required String access,
      required dynamic extra});

  Future<String> signup(
      {required String namespace,
      required String database,
      required String access,
      required dynamic extra});

  Future<void> unset({required String key});

  Future<dynamic> updateContent(
      {required String resource, required dynamic data});

  Future<dynamic> updateMerge(
      {required String resource, required dynamic data});

  Future<dynamic> upsert({required String res, required dynamic data});

  Future<void> useDb({required String db});

  Future<void> useNs({required String namespace});

  Future<String> version();

  Stream<DBNotification> watch({required String resource});
}

enum Action {
  create,
  update,
  delete,
  ;
}

class DBNotification {
  final Action action;
  final dynamic value;
  final String uuid;

  const DBNotification({
    required this.action,
    required this.value,
    required this.uuid,
  });

  @override
  int get hashCode => action.hashCode ^ value.hashCode ^ uuid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DBNotification &&
          runtimeType == other.runtimeType &&
          action == other.action &&
          value == other.value &&
          uuid == other.uuid;
}
